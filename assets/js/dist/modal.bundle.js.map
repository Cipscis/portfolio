{"version":3,"sources":["webpack://@cipscis/portfolio/webpack/bootstrap","webpack://@cipscis/portfolio/webpack/runtime/define property getters","webpack://@cipscis/portfolio/webpack/runtime/hasOwnProperty shorthand","webpack://@cipscis/portfolio/webpack/runtime/make namespace object","webpack://@cipscis/portfolio/./node_modules/@cipscis/activate/dist/activate.js","webpack://@cipscis/portfolio/./node_modules/@cipscis/keybinding/dist/KeyBind.js","webpack://@cipscis/portfolio/./node_modules/@cipscis/keybinding/dist/KeyPress.js","webpack://@cipscis/portfolio/./node_modules/@cipscis/keybinding/dist/keybinding.js","webpack://@cipscis/portfolio/./node_modules/@cipscis/pubsub/dist/pubsub.js","webpack://@cipscis/portfolio/./app/assets/js/src/modal/modal.js","webpack://@cipscis/portfolio/./app/assets/js/src/modal/example.js"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","boundEvents","Map","_activator","elements","fn","activator","document","querySelectorAll","e","DOMException","_deactivateSingle","HTMLElement","forEach","element","_activateSingle","TypeError","_getElementBindings","addEventListener","HTMLButtonElement","_getElementHasBindings","_preventSpacebarScroll","spacebarFn","_isSpacebar","this","_makeSpacebarFn","bindings","HTMLAnchorElement","enterFn","toLowerCase","_isEnter","_makeEnterFn","elementB","set","fnB","assign","_rememberElementBindings","removeEventListener","delete","_forgetElementBindings","has","isButton","isInput","HTMLInputElement","HTMLTextAreaElement","isSpacebar","preventDefault","KeyBind","Array","bindingString","RangeError","super","trim","split","binding","push","join","keyPresses","length","i","keyPress","entries","keyBind","match","Patterns","freeze","alt","ctrl","shift","Aliases","KeyPress","options","modifiers","altKey","ctrlKey","metaKey","shiftKey","keyString","requiredModifiers","modifier","test","replace","defaults","allowInInput","createFnWrapper","opts","keyLog","otherArgs","includes","activeElement","isProtected","splice","apply","bind","keyStringBindings","fnWrapper","unbind","$element","HTMLSelectElement","inputType","type","isContentEditable","subscriptions","subscribe","event","callback","events","filter","str","callbacks","activate","keys","selectors","$focus","$active","focusable","$el","isFocusable","focusIfNotDisabled","matches","isNotDisabled","disabled","focusThroughHref","focusThroughTabindex","isVisible","style","window","getComputedStyle","visibility","display","visible","tabbable","untabbableTabIndex","module","init","_onShow","onShow","_initEvents","_initSubscriptions","_processTriggerClick","_hideEvent","_showById","_hide","_bindModalActiveEvents","_hideIfBackgroundClick","el","_wrapTab","_unbindModalActiveEvents","$trigger","target","closest","targetId","getAttribute","substring","$target","$body","querySelector","isInModal","afterModal","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","$tabbable","_getTabbable","focus","$this","id","$modal","_show","setAttribute","bodyOpenClass","_getBodyOpenClass","classList","add","$focusable","_getFocusable","remove","undefined","$descendents"],"mappings":"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","file":"modal.bundle.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const boundEvents = new Map();\r\n/**\r\n * Handles the conversion of the elements parameter so the activator function only ever has to deal with single HTMLElements.\r\n *\r\n * @param {string | HTMLElement | NodeListOf<HTMLElement>} elements - A CSS selector string, HTMLElement, or NodeList of HTMLElements to be converted so the activator function is called once for each resulting HTMLElement.\r\n * @param {ActivateEventListener} fn - The event listener to bind to each HTMLElement.\r\n * @param {(element: HTMLElement, fn: ActivateEventListener) => void} activator - The function to link each HTMLElement to fn.\r\n *\r\n * @throws {DOMException} - If the elements argument is an invalid CSS selector string.\r\n */\r\nfunction _activator(elements, fn, activator) {\r\n    // Share the same initial logic between activate and deactivate,\r\n    // but run a different function over each element\r\n    if (typeof elements === 'string') {\r\n        try {\r\n            elements = document.querySelectorAll(elements);\r\n        }\r\n        catch (e) {\r\n            const method = activator === _deactivateSingle ? 'deactivate' : 'activate';\r\n            throw new DOMException(`${method} failed because it was passed an invalid selector string: '${elements}'`);\r\n        }\r\n    }\r\n    if (elements instanceof HTMLElement) {\r\n        activator(elements, fn);\r\n    }\r\n    else {\r\n        elements.forEach((element) => activator(element, fn));\r\n    }\r\n}\r\n/**\r\n * Binds fn to a single element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n *\r\n * @throws {TypeError} - element must be an HTMLElement.\r\n */\r\nfunction _activateSingle(element, fn) {\r\n    if (!(element instanceof HTMLElement)) {\r\n        throw new TypeError(`activate failed because a valid HTMLElement was not passed`);\r\n    }\r\n    if (_getElementBindings(element, fn)) {\r\n        // Like addEventListener, don't try to rebind new copies of the same events\r\n        return;\r\n    }\r\n    // All nodes should bind the click event\r\n    element.addEventListener('click', fn);\r\n    // Buttons will already treat keyboard events like clicks,\r\n    // so only bind them to other element types\r\n    if (!(element instanceof HTMLButtonElement)) {\r\n        if (_getElementHasBindings(element) === false) {\r\n            // addEventListener would prevent this event being\r\n            // bound multiple times, but be explicit that it is\r\n            // only bound if the element has no other events bound\r\n            element.addEventListener('keydown', _preventSpacebarScroll);\r\n        }\r\n        const spacebarFn = _makeSpacebarFn(fn);\r\n        element.addEventListener('keyup', spacebarFn);\r\n        const bindings = {\r\n            spacebarFn\r\n        };\r\n        // Links already treat \"enter\" keydown like a click\r\n        if (!(element instanceof HTMLAnchorElement)) {\r\n            // Note that holding down \"enter\" will behave differently\r\n            // for links in that it will only fire once, whereas for\r\n            // non-links, including buttons, it will fire multiple times\r\n            const enterFn = _makeEnterFn(fn);\r\n            element.addEventListener('keydown', enterFn);\r\n            bindings.enterFn = enterFn;\r\n        }\r\n        _rememberElementBindings(element, fn, bindings);\r\n    }\r\n}\r\n/**\r\n * Unbinds fn from a single element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n *\r\n * @throws {TypeError} - element must be an HTMLElement.\r\n */\r\nfunction _deactivateSingle(element, fn) {\r\n    if (!(element instanceof HTMLElement)) {\r\n        throw new TypeError(`deactivate failed because a valid HTMLElement was not passed`);\r\n    }\r\n    // All elements have had a click event bound\r\n    element.removeEventListener('click', fn);\r\n    const bindings = _getElementBindings(element, fn);\r\n    if (!bindings) {\r\n        // No other events to unbind\r\n        return;\r\n    }\r\n    // Buttons will already treat keyboard events like clicks,\r\n    // so they didn't have keyboard events bound to them\r\n    if (!(element instanceof HTMLButtonElement)) {\r\n        if (bindings.spacebarFn) {\r\n            element.removeEventListener('keyup', bindings.spacebarFn);\r\n        }\r\n        // Links already treat \"enter\" keydown like a click,\r\n        // so that event wasn't bound to them\r\n        if (!(element instanceof HTMLAnchorElement)) {\r\n            if (bindings.enterFn) {\r\n                element.removeEventListener('keydown', bindings.enterFn);\r\n            }\r\n        }\r\n        _forgetElementBindings(element, fn);\r\n        if (_getElementHasBindings(element) === false) {\r\n            // Only unbind this event if the element has no other bindings\r\n            element.removeEventListener('keydown', _preventSpacebarScroll);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Record a new set of bindings for a particular element, associated with a new primary binding.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn - The primary binding.\r\n * @param {ActivateBinding} bindings - The secondary bindings.\r\n */\r\nfunction _rememberElementBindings(element, fn, bindings) {\r\n    let elementB = boundEvents.get(element);\r\n    if (!elementB) {\r\n        elementB = new Map([[fn, bindings]]);\r\n        boundEvents.set(element, elementB);\r\n    }\r\n    let fnB = elementB.get(fn);\r\n    if (fnB) {\r\n        Object.assign(fnB, bindings);\r\n    }\r\n    else {\r\n        fnB = Object.assign({}, bindings);\r\n        elementB.set(fn, fnB);\r\n    }\r\n}\r\n/**\r\n * Delete any records of bindings for a particular element and primary binding pair.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n */\r\nfunction _forgetElementBindings(element, fn) {\r\n    const elementB = boundEvents.get(element);\r\n    if (!elementB) {\r\n        return;\r\n    }\r\n    elementB.delete(fn);\r\n    boundEvents.delete(element);\r\n}\r\n/**\r\n * Return the bindings for a particular element and primary binding pair.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n */\r\nfunction _getElementBindings(element, fn) {\r\n    const elementB = boundEvents.get(element);\r\n    if (!elementB) {\r\n        return undefined;\r\n    }\r\n    const fnB = elementB.get(fn);\r\n    return fnB;\r\n}\r\n/**\r\n * Checks whether or not any bindings are recorded for a particular element and primary binding pair.\r\n *\r\n * @param  {HTMLElement} element\r\n *\r\n * @return {boolean}\r\n */\r\nfunction _getElementHasBindings(element) {\r\n    return boundEvents.has(element);\r\n}\r\nfunction _makeEnterFn(fn) {\r\n    return function (e) {\r\n        const isEnter = _isEnter(e);\r\n        if (isEnter) {\r\n            return fn.call(this, e);\r\n        }\r\n    };\r\n}\r\n/**\r\n * For a given KeyboardEvent, checks if it was triggered by the 'enter' key.\r\n *\r\n * @param  {KeyboardEvent} e\r\n *\r\n * @return {boolean}\r\n */\r\nfunction _isEnter(e) {\r\n    const isEnter = !!(e.key && (e.key.toLowerCase() === 'enter'));\r\n    return isEnter;\r\n}\r\n/**\r\n * For a given KeyboardEvent, if it was triggered by the 'spacebar' key, prevent the default action of scrolling the page.\r\n *\r\n * @param {KeyboardEvent} e\r\n */\r\nfunction _preventSpacebarScroll(e) {\r\n    // Prevent spacebar from scrolling the page down on keydown\r\n    const element = this;\r\n    // Buttons and inputs don't have this default action of the 'spacebar' key, so don't prevent it.\r\n    const isButton = element instanceof HTMLButtonElement;\r\n    const isInput = element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement;\r\n    const isSpacebar = _isSpacebar(e);\r\n    if (!isButton && !isInput && isSpacebar) {\r\n        e.preventDefault();\r\n    }\r\n}\r\n/**\r\n * Create a secondary binding that calls fn when triggered via the spacebar.\r\n *\r\n * @param {ActivateEventListener} fn\r\n */\r\nfunction _makeSpacebarFn(fn) {\r\n    return function (e) {\r\n        const isSpacebar = _isSpacebar(e);\r\n        if (isSpacebar) {\r\n            return fn.call(this, e);\r\n        }\r\n    };\r\n}\r\n/**\r\n * Checks if a given KeyboardEvent was triggered by the 'spacebar' key.\r\n *\r\n * @param  {KeyboardEvent} e\r\n *\r\n * @return {boolean}\r\n */\r\nfunction _isSpacebar(e) {\r\n    // IE11 uses 'spacebar' instead of ' '\r\n    const isSpacebar = !!(e.key && (e.key === ' ' || e.key.toLowerCase() === 'spacebar'));\r\n    return isSpacebar;\r\n}\r\n/**\r\n * Bind fn to all specified elements.\r\n *\r\n * @param {string | HTMLElement | NodeListOf<HTMLElement>} elements - The elements to have fn bound to them.\r\n * @param {ActivateEventListener} fn - The event listener to bind.\r\n *\r\n * @throws {DOMException} - If the elements argument is an invalid CSS selector string.\r\n */\r\nfunction activate(elements, fn) {\r\n    _activator(elements, fn, _activateSingle);\r\n}\r\n/**\r\n * Unbind fn from all specified elements.\r\n *\r\n * @param {string | HTMLElement | NodeListOf<HTMLElement>} elements - The elements to have fn unbound from them.\r\n * @param {ActivateEventListener} fn - The event listener to unbind.\r\n *\r\n * @throws {DOMException} - If the elements argument is an invalid CSS selector string.\r\n */\r\nfunction deactivate(elements, fn) {\r\n    _activator(elements, fn, _deactivateSingle);\r\n}\r\nexport { activate, deactivate, };\r\nexport default activate;\r\n//# sourceMappingURL=activate.js.map","class KeyBind extends Array {\r\n    /**\r\n     * Creates a special KeyBind array based on a string representation of a\r\n     *   key, key combination, or key sequence.\r\n     *\r\n     * @constructor\r\n     *\r\n     * @param {string} bindingString - A string representing a key, key combination, or key sequence. For example, 'esc' or 'Ctrl+G Ctrl+D'.\r\n     */\r\n    constructor(bindingString) {\r\n        if (!(typeof bindingString === 'string')) {\r\n            throw new RangeError(`KeyBind: Constructor argument must be a string`);\r\n        }\r\n        super(0);\r\n        const bindings = bindingString.trim().split(/\\s+/g);\r\n        for (const binding of bindings) {\r\n            this.push(binding);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a string representation of a KeyBind.\r\n     *\r\n     * @return {string}\r\n     */\r\n    toString() {\r\n        return this.join(' ');\r\n    }\r\n    /**\r\n     * Checks whether or not a given set of KeyPresses matches the current\r\n     *   KeyBind's criteria.\r\n     *\r\n     * @param  {KeyPress[]} keyPresses - The KeyPresses to check against.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    match(keyPresses) {\r\n        if (keyPresses.length !== this.length) {\r\n            return false;\r\n        }\r\n        for (const [i, keyPress] of keyPresses.entries()) {\r\n            const keyBind = this[i];\r\n            if (!keyPress.match(keyBind)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexport { KeyBind };\r\n//# sourceMappingURL=KeyBind.js.map","const Patterns = Object.freeze({\r\n    alt: /\\balt\\+/g,\r\n    ctrl: /\\b(control|ctrl|command|cmd|meta)\\+/g,\r\n    shift: /\\bshift\\+/g,\r\n});\r\nconst Aliases = new Map([\r\n    ['space', ' '],\r\n    ['spacebar', ' '],\r\n    ['up', 'arrowup'],\r\n    ['right', 'arrowright'],\r\n    ['down', 'arrowdown'],\r\n    ['left', 'arrowleft'],\r\n    ['esc', 'escape'],\r\n]);\r\n;\r\nclass KeyPress {\r\n    key;\r\n    modifiers;\r\n    /**\r\n     * Creates a recording of a key press, including any modifier keys that were\r\n     *   pressed at the time.\r\n     *\r\n     * @constructor\r\n     *\r\n     * @param {Object} options - Can accept a KeyboardEvent.\r\n     * @param {string} options.key - The key that was pressed.\r\n     * @param {boolean?} altKey - Whether or not the Alt key was pressed.\r\n     * @param {boolean?} metaKey - Whether or not the Meta key was pressed.\r\n     * @param {boolean?} ctrlKey - Whether or not the Ctrl key was pressed.\r\n     * @param {boolean?} shiftKey - Whether or not the Shift key was pressed.\r\n     */\r\n    constructor(options) {\r\n        if (!('key' in options)) {\r\n            throw new RangeError(`KeyPress: key is a required option`);\r\n        }\r\n        this.key = options.key;\r\n        this.modifiers = {\r\n            altKey: options.altKey || false,\r\n            ctrlKey: options.metaKey || options.ctrlKey || false,\r\n            shiftKey: options.shiftKey || false,\r\n        };\r\n    }\r\n    /**\r\n     * Checks whether or not a given string representing a key or a key\r\n     *   combination matches the current recorded KeyPress.\r\n     *\r\n     * @param  {string} keyString A string representing a key or key\r\n     *   combination. For example, 'esc' or 'Ctrl+G'.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    match(keyString) {\r\n        const requiredModifiers = {\r\n            altKey: false,\r\n            ctrlKey: false,\r\n            shiftKey: false,\r\n        };\r\n        // Gather required modifiers for keyString\r\n        if (Patterns.alt.test(keyString)) {\r\n            requiredModifiers.altKey = true;\r\n            keyString = keyString.replace(Patterns.alt, '');\r\n        }\r\n        if (Patterns.ctrl.test(keyString)) {\r\n            requiredModifiers.ctrlKey = true;\r\n            keyString = keyString.replace(Patterns.ctrl, '');\r\n        }\r\n        if (Patterns.shift.test(keyString)) {\r\n            requiredModifiers.shiftKey = true;\r\n            keyString = keyString.replace(Patterns.shift, '');\r\n        }\r\n        // Check if all keyString's required modifiers were met\r\n        let modifier;\r\n        for (modifier in requiredModifiers) {\r\n            if (requiredModifiers[modifier] && !this.modifiers[modifier]) {\r\n                // The modifier was required but not recorded\r\n                return false;\r\n            }\r\n        }\r\n        // Check if they keyString's key matches the key pressed\r\n        if (keyString.toLowerCase() === this.key.toLowerCase()) {\r\n            return true;\r\n        }\r\n        // Check if the keyString is an alias for a matching key\r\n        if (Aliases.get(keyString.toLowerCase()) === this.key.toLowerCase()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexport { KeyPress };\r\n//# sourceMappingURL=KeyPress.js.map","import { KeyBind } from './KeyBind.js';\r\nimport { KeyPress } from './KeyPress.js';\r\nconst bindings = new Map();\r\nconst defaults = Object.freeze({\r\n    allowInInput: false,\r\n});\r\n/**\r\n * Creates a wrapper for a callback function, which handles recording and\r\n *   checking keypresses so it can be bound directly to the 'keydown' event and\r\n *   decide when the callback should be invoked.\r\n *\r\n * @param {string} keyString - A string representing the key, key combination,\r\n *   or key sequence the callback should to be bound to. For example, 'esc' or\r\n *   'Ctrl+G Ctrl+D'.\r\n * @param {function} fn - The function to be bound.\r\n * @param {Object} options - Options to configure behaviour of the key binding.\r\n * @param {boolean} options.allowInInput - If set to true, the key binding will remain active while keyboard focus is in an element that can receive keyboard input, such as <input type=\"text\">.\r\n *\r\n * @return {function}\r\n */\r\nconst createFnWrapper = (keyString, fn, opts) => {\r\n    const options = Object.assign({}, defaults, opts);\r\n    const keyBind = new KeyBind(keyString);\r\n    const keyLog = [];\r\n    const fnWrapper = function (e, ...otherArgs) {\r\n        // Ignore modifier keys\r\n        if (['Alt', 'Control', 'Meta', 'Shift'].includes(e.key)) {\r\n            return;\r\n        }\r\n        // Don't check key if focus is in a prohibited place\r\n        if ((!options.allowInInput) && isInput(document.activeElement)) {\r\n            return;\r\n        }\r\n        if (isProtected(document.activeElement)) {\r\n            return;\r\n        }\r\n        const keyPress = new KeyPress(e);\r\n        keyLog.push(keyPress);\r\n        if (keyLog.length > keyBind.length) {\r\n            keyLog.shift();\r\n        }\r\n        if (keyBind.match(keyLog)) {\r\n            // Clear keyLog and call function\r\n            keyLog.splice(0);\r\n            fn.apply(this, [e, ...otherArgs]);\r\n        }\r\n    };\r\n    return fnWrapper;\r\n};\r\n/**\r\n * Binds an event to a key, key combination, or key sequence.\r\n *\r\n * @param {string} keyString - A string representing the key, key combination, or key sequence to be bound to. For example, 'esc' or 'Ctrl+G Ctrl+D'.\r\n * @param {function} fn - The function to be bound. When called, behaves as though it had been bound by document.addEventListener.\r\n * @param {Object} options - Options to configure behaviour of the key binding.\r\n * @param {boolean} options.allowInInput - If set to true, the key binding will remain active while keyboard focus is in an element that can receive keyboard input, such as <input type=\"text\">.\r\n *\r\n * @return {void}\r\n */\r\nconst bind = (keyString, fn, options) => {\r\n    if (!bindings.has(keyString)) {\r\n        bindings.set(keyString, new Map());\r\n    }\r\n    const keyStringBindings = bindings.get(keyString);\r\n    if (keyStringBindings.has(fn)) {\r\n        // Do nothing - this binding already exists\r\n        return;\r\n    }\r\n    const fnWrapper = createFnWrapper(keyString, fn, options);\r\n    document.addEventListener('keydown', fnWrapper);\r\n    keyStringBindings.set(fn, fnWrapper);\r\n};\r\n/**\r\n * Unbind an event from a key, key combination, or key sequence.\r\n *\r\n * @param {string} keyString - A string representing the key, key combination, or key sequence to unbind from. For example, 'esc' or 'Ctrl+G Ctrl+D'.\r\n * @param {function} fn - The function to be unbound.\r\n *\r\n * @return {void}\r\n */\r\nconst unbind = (keyString, fn) => {\r\n    const keyStringBindings = bindings.get(keyString);\r\n    if (!keyStringBindings) {\r\n        return;\r\n    }\r\n    const fnWrapper = keyStringBindings.get(fn);\r\n    if (fnWrapper) {\r\n        document.removeEventListener('keydown', fnWrapper);\r\n        keyStringBindings.delete(fn);\r\n    }\r\n};\r\n/**\r\n * Check if a given HTMLElement is able to receive keyboard input.\r\n *\r\n * @param  {Element | null} $element - The element to check. If it is not an\r\n *   HTMLElement, the function will return false.\r\n *\r\n * @return {boolean}\r\n */\r\nconst isInput = function ($element) {\r\n    let isInput = false;\r\n    if ($element instanceof HTMLElement) {\r\n        if ($element instanceof HTMLTextAreaElement || $element instanceof HTMLSelectElement) {\r\n            isInput = true;\r\n        }\r\n        else if ($element instanceof HTMLInputElement) {\r\n            isInput = true;\r\n            const inputType = ($element.type || 'text').toLowerCase();\r\n            if (['button', 'checkbox', 'color', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'].includes(inputType)) {\r\n                isInput = false;\r\n            }\r\n        }\r\n        else if ($element.isContentEditable) {\r\n            isInput = true;\r\n        }\r\n    }\r\n    return isInput;\r\n};\r\n/**\r\n * Check if keyboard input to an HTMLElement should never be tracked.\r\n *\r\n * @param  {Element | null} $element - The element to check. If it is not an\r\n *   HTMLElement, the function will return false.\r\n *\r\n * @return {boolean}\r\n */\r\nconst isProtected = function ($element) {\r\n    let isProtected = false;\r\n    if ($element instanceof HTMLInputElement) {\r\n        const inputType = ($element.type || 'text').toLowerCase();\r\n        if (inputType === 'password') {\r\n            isProtected = true;\r\n        }\r\n    }\r\n    return isProtected;\r\n};\r\nexport { bind, unbind, };\r\n//# sourceMappingURL=keybinding.js.map","const subscriptions = {};\r\n// Split by whitespace, then remove any empty strings\r\nconst split = (eventString) => eventString.split(/\\s+/).filter(str => !!str);\r\nconst publish = function (event, ...args) {\r\n    const events = split(event);\r\n    if (events.length > 1) {\r\n        for (const event of events) {\r\n            publish.call(this, event, ...args);\r\n        }\r\n    }\r\n    else if (event in subscriptions) {\r\n        const callbacks = subscriptions[event];\r\n        callbacks.forEach((callback) => {\r\n            callback.apply(null, args);\r\n        });\r\n    }\r\n};\r\nconst subscribe = function (event, callback) {\r\n    const events = split(event);\r\n    if (events.length > 1) {\r\n        for (const event of events) {\r\n            subscribe(event, callback);\r\n        }\r\n    }\r\n    else {\r\n        if (!(event in subscriptions)) {\r\n            subscriptions[event] = [];\r\n        }\r\n        const callbacks = subscriptions[event];\r\n        // Don't bind a particular function to an event more than once\r\n        if (callbacks.includes(callback) === false) {\r\n            callbacks.push(callback);\r\n        }\r\n    }\r\n};\r\nconst unsubscribe = function (event, callback) {\r\n    if (event in subscriptions) {\r\n        const callbacks = subscriptions[event];\r\n        const index = callbacks.indexOf(callback);\r\n        if (index !== -1) {\r\n            callbacks.splice(index, 1);\r\n        }\r\n    }\r\n};\r\nexport { publish, subscribe, unsubscribe };\r\n//# sourceMappingURL=pubsub.js.map","/* Modal 1.1 */\n\nimport { activate } from '@cipscis/activate';\nimport * as keys from '@cipscis/keybinding';\nimport { subscribe } from '@cipscis/pubsub';\n\nconst modal = (function (activate, keys, subscribe) {\n\tconst selectors = {\n\t\tmodal: '.js-modal',\n\t\tbody: '.js-modal__body',\n\t\ttrigger: '.js-modal__trigger',\n\t\tclose: '.js-modal__close'\n\t};\n\n\tconst dataSelectors = {\n\t\tbodyOpenClass: 'modal-body-open-class'\n\t};\n\n\tconst classes = {\n\t\tbodyOpen: 'modal__body-open'\n\t};\n\n\tconst events = {\n\t\tshow: '/modal/show',\n\t\thide: '/modal/hide'\n\t};\n\n\tlet $focus = undefined; // The active modal window\n\tlet $active = undefined; // The element that had focus before opening the modal window\n\n\tconst visible = function ($el) {\n\t\tlet style = window.getComputedStyle($el);\n\n\t\tlet visibility = style.visibility;\n\t\tlet display = style.display;\n\n\t\tlet isVisible = visibility !== 'hidden' && display !== 'none';\n\n\t\treturn isVisible;\n\t};\n\n\t// Callback for passing into Array.prototype.filter\n\tconst focusable = function ($el) {\n\t\tlet focusIfNotDisabled = $el.matches('input, select, textarea, button, object');\n\t\tlet isNotDisabled = $el.disabled === false;\n\n\t\tlet focusThroughHref = $el.matches('a, area') && $el.matches('[href]');\n\t\tlet focusThroughTabindex = $el.matches('[tabindex]');\n\n\t\tlet isFocusable;\n\t\tif (focusIfNotDisabled) {\n\t\t\tisFocusable = isNotDisabled;\n\t\t} else {\n\t\t\tisFocusable = focusThroughHref || focusThroughTabindex;\n\t\t}\n\n\t\tlet isVisible = visible($el);\n\n\t\tisFocusable = isFocusable && isVisible;\n\n\t\treturn isFocusable;\n\t};\n\n\t// Callback for passing into Array.prototype.filter\n\tconst tabbable = function ($el) {\n\t\tlet isFocusable = focusable($el);\n\t\tlet untabbableTabIndex = $el.matches('[tabindex=\"-1\"]');\n\n\t\treturn isFocusable && !untabbableTabIndex;\n\t};\n\n\tconst module = {\n\t\tinit: function (options) {\n\t\t\toptions = options || {};\n\n\t\t\tmodule._onShow = options.onShow || (() => {});\n\n\t\t\tmodule._initEvents();\n\t\t\tmodule._initSubscriptions();\n\t\t},\n\n\t\t_initEvents: function () {\n\t\t\tactivate(selectors.trigger, module._processTriggerClick);\n\t\t\tactivate(selectors.close, module._hideEvent);\n\t\t},\n\n\t\t_initSubscriptions: function () {\n\t\t\tif (subscribe) {\n\t\t\t\tsubscribe(events.show, module._showById);\n\t\t\t\tsubscribe(events.hide, module._hide);\n\t\t\t}\n\t\t},\n\n\t\t_bindModalActiveEvents: function () {\n\t\t\tkeys.bind('escape', module._hide, true);\n\n\t\t\tdocument.addEventListener('click', module._hideIfBackgroundClick);\n\t\t\tdocument.querySelectorAll('*').forEach(el => el.addEventListener('focus', module._wrapTab));\n\t\t},\n\n\t\t_unbindModalActiveEvents: function () {\n\t\t\tkeys.unbind('escape', module._hide);\n\n\t\t\tdocument.removeEventListener('click', module._hideIfBackgroundClick);\n\t\t\tdocument.querySelectorAll('*').forEach(el => el.removeEventListener('focus', module._wrapTab));\n\t\t},\n\n\t\t// Event callbacks\n\t\t_processTriggerClick: function (e) {\n\t\t\tlet $trigger = e.target.closest(selectors.trigger);\n\t\t\tlet targetId = $trigger.getAttribute('href');\n\n\t\t\te.preventDefault();\n\n\t\t\tif (/^#/.test(targetId) === true) {\n\t\t\t\ttargetId = targetId.substring(1);\n\t\t\t} else {\n\t\t\t\ttargetId = $trigger.getAttribute('aria-controls');\n\t\t\t}\n\n\t\t\tmodule._showById(targetId);\n\t\t},\n\n\t\t_wrapTab: function (e) {\n\t\t\tlet $target = e.target;\n\t\t\tlet $body = $active.querySelector(selectors.body);\n\t\t\tlet isInModal = !!$target.closest(selectors.body);\n\t\t\tlet afterModal = $body.compareDocumentPosition($target) === Node.DOCUMENT_POSITION_FOLLOWING;\n\n\t\t\tif (!isInModal) {\n\t\t\t\te.preventDefault();\n\n\t\t\t\tlet $tabbable = module._getTabbable();\n\n\t\t\t\tif (afterModal) {\n\t\t\t\t\t// Wrap to start\n\t\t\t\t\t$tabbable[0].focus();\n\t\t\t\t} else {\n\t\t\t\t\t// Wrap to end\n\t\t\t\t\t$tabbable[$tabbable.length-1].focus();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_hideIfBackgroundClick: function (e) {\n\t\t\tlet $this = e.target;\n\n\t\t\tif ($this.closest(selectors.body)) {\n\t\t\t\t// Click was within the modal popup, so ignore it\n\t\t\t\treturn;\n\t\t\t} else if ($this.closest(selectors.trigger)) {\n\t\t\t\t// Click was within the trigger, so ignore it\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// Click was outside the modal popup, so close it\n\t\t\t\tmodule._hide();\n\t\t\t}\n\t\t},\n\n\t\t// Hide/Show functions\n\t\t_showById: function (id) {\n\t\t\tlet $modal = document.querySelector('#' + id);\n\n\t\t\tmodule._show($modal);\n\t\t},\n\n\t\t_show: function ($modal) {\n\t\t\tif ($active) {\n\t\t\t\t// If there's already an active modal window,\n\t\t\t\t// keep remembering the same $focus element\n\t\t\t\t$active.setAttribute('aria-hidden', true);\n\t\t\t} else {\n\t\t\t\t$focus = document.activeElement;\n\t\t\t}\n\t\t\t$active = $modal;\n\n\t\t\t$modal.setAttribute('aria-hidden', false);\n\t\t\tlet bodyOpenClass = module._getBodyOpenClass($modal);\n\t\t\tdocument.querySelector('body').classList.add(bodyOpenClass);\n\n\t\t\tmodule._onShow($modal);\n\n\t\t\t// Move focus within modal window\n\t\t\tlet $focusable = module._getFocusable();\n\t\t\tif ($focusable.length) {\n\t\t\t\t$focusable[0].focus();\n\t\t\t}\n\n\t\t\tmodule._bindModalActiveEvents();\n\t\t},\n\n\t\t_hideEvent: function (e) {\n\t\t\te.preventDefault();\n\t\t\tmodule._hide();\n\t\t},\n\n\t\t_hide: function () {\n\t\t\tif ($active) {\n\t\t\t\t$active.setAttribute('aria-hidden', true);\n\t\t\t\tlet bodyOpenClass = module._getBodyOpenClass($active);\n\t\t\t\tdocument.querySelector('body').classList.remove(bodyOpenClass);\n\n\t\t\t\tmodule._unbindModalActiveEvents();\n\n\t\t\t\t// Return focus where it was\n\t\t\t\tif ($focus) {\n\t\t\t\t\t$focus.focus();\n\t\t\t\t}\n\n\t\t\t\t$active = undefined;\n\t\t\t\t$focus = undefined;\n\t\t\t}\n\t\t},\n\n\t\t_getBodyOpenClass: function ($modal) {\n\t\t\tlet bodyOpenClass = $modal.getAttribute(`data-${dataSelectors.bodyOpenClass}`) || classes.bodyOpen;\n\n\t\t\treturn bodyOpenClass;\n\t\t},\n\n\t\t// Focus management\n\t\t_getFocusable: function ($modal) {\n\t\t\t$modal = $modal || $active;\n\t\t\tlet $body = $modal.querySelector(selectors.body);\n\n\t\t\tlet $descendents = $body.querySelectorAll('*');\n\t\t\tlet $focusable = Array.prototype.filter.call($descendents, focusable);\n\n\t\t\treturn $focusable;\n\t\t},\n\n\t\t_getTabbable: function ($modal) {\n\t\t\t$modal = $modal || $active;\n\t\t\tlet $body = $modal.querySelector(selectors.body);\n\n\t\t\tlet $descendents = $body.querySelectorAll('*');\n\t\t\tlet $tabbable = Array.prototype.filter.call($descendents, tabbable);\n\n\t\t\treturn $tabbable;\n\t\t}\n\t};\n\n\treturn {\n\t\tinit: module.init\n\t};\n})(activate, keys, subscribe);\n\nexport { modal };\nexport default modal;\n","import { modal } from './modal.js';\n\nmodal.init();\n"],"sourceRoot":""}