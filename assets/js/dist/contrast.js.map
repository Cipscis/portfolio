{"version":3,"file":"contrast.js","mappings":"mBAaA,IAAKA,ECbe,IAAIC,IDENC,OAAOC,OAAO,CAC/BC,OAAQ,yBAGOF,OAAOC,OAAO,CAC7BE,MAAO,aACPC,KAAM,YAENC,iBAAkB,sBAGnB,SAAKP,GACJ,gBACA,cAFD,CAAKA,IAAAA,EAAI,M","sources":["webpack://@cipscis/portfolio/./app/assets/js/src/contrast/contrast.ts","webpack://@cipscis/portfolio/./node_modules/@cipscis/activate/dist/activate.js"],"sourcesContent":["import { activate } from '@cipscis/activate';\n\nconst selectors = Object.freeze({\n\ttoggle: '.js-toggle-dark-mode',\n} as const);\n\nconst classes = Object.freeze({\n\tlight: 'light-mode',\n\tdark: 'dark-mode',\n\n\tallowTransitions: 'allow-transitions',\n} as const);\n\nenum Mode {\n\tLIGHT = 'light',\n\tDARK = 'dark',\n}\n\nconst localStorageKey = 'contrast-mode';\n\nfunction init(): void {\n\t_initMode();\n\t_initEvents();\n\n\twindow.setTimeout(_allowTransitions, 100);\n}\n\n/**\n * If a mode has been remembered in localStorage, apply it */\nfunction _initMode(): void {\n\tconst initialMode = _recallMode();\n\n\tif (initialMode) {\n\t\t_setMode(initialMode);\n\t}\n}\n\n/**\n * Bind all event listeners.\n */\nfunction _initEvents(): void {\n\tactivate(selectors.toggle, _toggleMode);\n}\n\n/**\n * CSS transitions implemented with the `transition` mixin\n * require an `allow-transitions` class on the body. This\n * prevents flashing when setting the initial contrast mode\n * with JavaScript.\n */\nfunction _allowTransitions(): void {\n\tconst $body = document.querySelector('body') as HTMLBodyElement;\n\n\t$body.classList.add(classes.allowTransitions);\n}\n\n/**\n * Retrieve the currently active mode.\n */\nfunction _getMode(): Mode {\n\tconst $body = document.querySelector('body') as HTMLBodyElement;\n\n\tif ($body.classList.contains(classes.dark)) {\n\t\treturn Mode.DARK;\n\t} else if ($body.classList.contains(classes.light)) {\n\t\treturn Mode.LIGHT;\n\t} else if (matchMedia('(prefers-color-scheme: dark)').matches) {\n\t\treturn Mode.DARK;\n\t} else if (matchMedia('(prefers-color-scheme: light)').matches) {\n\t\treturn Mode.LIGHT;\n\t} else {\n\t\treturn Mode.LIGHT;\n\t}\n}\n\n/**\n * Set the currently active mode by applying a class to the body element.\n */\nfunction _setMode(mode: Mode): void {\n\tconst $body = document.querySelector('body') as HTMLBodyElement;\n\n\tswitch (mode) {\n\t\tcase Mode.LIGHT:\n\t\t\t$body.classList.remove(classes.dark);\n\t\t\t$body.classList.add(classes.light);\n\t\t\tbreak;\n\n\t\tcase Mode.DARK:\n\t\t\t$body.classList.remove(classes.light);\n\t\t\t$body.classList.add(classes.dark);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow new TypeError(`Unrecognised mode: ${mode}`);\n\t}\n\n\t_rememberMode(mode);\n}\n\n/**\n * Toggle the currently active mode.\n */\nfunction _toggleMode(): void {\n\tconst currentMode = _getMode();\n\tconst newMode = currentMode === Mode.LIGHT ? Mode.DARK : Mode.LIGHT;\n\n\t_setMode(newMode);\n}\n\n/**\n * Remember a given mode in localStorage.\n */\nfunction _rememberMode(mode: Mode): void {\n\tlocalStorage.setItem(localStorageKey, mode);\n}\n\n/**\n * Recall a remembered mode from localStorage.\n */\nfunction _recallMode(): Mode | null {\n\tconst mode = localStorage.getItem(localStorageKey);\n\n\tconst isMode = (mode: unknown): mode is Mode => Object.values(Mode).includes(mode as Mode);\n\n\tif (isMode(mode)) {\n\t\treturn mode;\n\t} else {\n\t\treturn null;\n\t}\n}\n\nexport { init };\n","const boundEvents = new Map();\r\n/**\r\n * Handles the conversion of the elements parameter so the activator function only ever has to deal with single HTMLElements.\r\n *\r\n * @param {string | HTMLElement | NodeListOf<HTMLElement>} elements - A CSS selector string, HTMLElement, or NodeList of HTMLElements to be converted so the activator function is called once for each resulting HTMLElement.\r\n * @param {ActivateEventListener} fn - The event listener to bind to each HTMLElement.\r\n * @param {(element: HTMLElement, fn: ActivateEventListener) => void} activator - The function to link each HTMLElement to fn.\r\n *\r\n * @throws {DOMException} - If the elements argument is an invalid CSS selector string.\r\n */\r\nfunction _activator(elements, fn, activator) {\r\n    // Share the same initial logic between activate and deactivate,\r\n    // but run a different function over each element\r\n    if (typeof elements === 'string') {\r\n        try {\r\n            elements = document.querySelectorAll(elements);\r\n        }\r\n        catch (e) {\r\n            const method = activator === _deactivateSingle ? 'deactivate' : 'activate';\r\n            throw new DOMException(`${method} failed because it was passed an invalid selector string: '${elements}'`);\r\n        }\r\n    }\r\n    if (elements instanceof HTMLElement) {\r\n        activator(elements, fn);\r\n    }\r\n    else {\r\n        elements.forEach((element) => activator(element, fn));\r\n    }\r\n}\r\n/**\r\n * Binds fn to a single element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n *\r\n * @throws {TypeError} - element must be an HTMLElement.\r\n */\r\nfunction _activateSingle(element, fn) {\r\n    if (!(element instanceof HTMLElement)) {\r\n        throw new TypeError(`activate failed because a valid HTMLElement was not passed`);\r\n    }\r\n    if (_getElementBindings(element, fn)) {\r\n        // Like addEventListener, don't try to rebind new copies of the same events\r\n        return;\r\n    }\r\n    // All nodes should bind the click event\r\n    element.addEventListener('click', fn);\r\n    // Buttons will already treat keyboard events like clicks,\r\n    // so only bind them to other element types\r\n    if (!(element instanceof HTMLButtonElement)) {\r\n        if (_getElementHasBindings(element) === false) {\r\n            // addEventListener would prevent this event being\r\n            // bound multiple times, but be explicit that it is\r\n            // only bound if the element has no other events bound\r\n            element.addEventListener('keydown', _preventSpacebarScroll);\r\n        }\r\n        const spacebarFn = _makeSpacebarFn(fn);\r\n        element.addEventListener('keyup', spacebarFn);\r\n        const bindings = {\r\n            spacebarFn\r\n        };\r\n        // Links already treat \"enter\" keydown like a click\r\n        if (!(element instanceof HTMLAnchorElement)) {\r\n            // Note that holding down \"enter\" will behave differently\r\n            // for links in that it will only fire once, whereas for\r\n            // non-links, including buttons, it will fire multiple times\r\n            const enterFn = _makeEnterFn(fn);\r\n            element.addEventListener('keydown', enterFn);\r\n            bindings.enterFn = enterFn;\r\n        }\r\n        _rememberElementBindings(element, fn, bindings);\r\n    }\r\n}\r\n/**\r\n * Unbinds fn from a single element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n *\r\n * @throws {TypeError} - element must be an HTMLElement.\r\n */\r\nfunction _deactivateSingle(element, fn) {\r\n    if (!(element instanceof HTMLElement)) {\r\n        throw new TypeError(`deactivate failed because a valid HTMLElement was not passed`);\r\n    }\r\n    // All elements have had a click event bound\r\n    element.removeEventListener('click', fn);\r\n    const bindings = _getElementBindings(element, fn);\r\n    if (!bindings) {\r\n        // No other events to unbind\r\n        return;\r\n    }\r\n    // Buttons will already treat keyboard events like clicks,\r\n    // so they didn't have keyboard events bound to them\r\n    if (!(element instanceof HTMLButtonElement)) {\r\n        if (bindings.spacebarFn) {\r\n            element.removeEventListener('keyup', bindings.spacebarFn);\r\n        }\r\n        // Links already treat \"enter\" keydown like a click,\r\n        // so that event wasn't bound to them\r\n        if (!(element instanceof HTMLAnchorElement)) {\r\n            if (bindings.enterFn) {\r\n                element.removeEventListener('keydown', bindings.enterFn);\r\n            }\r\n        }\r\n        _forgetElementBindings(element, fn);\r\n        if (_getElementHasBindings(element) === false) {\r\n            // Only unbind this event if the element has no other bindings\r\n            element.removeEventListener('keydown', _preventSpacebarScroll);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Record a new set of bindings for a particular element, associated with a new primary binding.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn - The primary binding.\r\n * @param {ActivateBinding} bindings - The secondary bindings.\r\n */\r\nfunction _rememberElementBindings(element, fn, bindings) {\r\n    let elementB = boundEvents.get(element);\r\n    if (!elementB) {\r\n        elementB = new Map([[fn, bindings]]);\r\n        boundEvents.set(element, elementB);\r\n    }\r\n    let fnB = elementB.get(fn);\r\n    if (fnB) {\r\n        Object.assign(fnB, bindings);\r\n    }\r\n    else {\r\n        fnB = Object.assign({}, bindings);\r\n        elementB.set(fn, fnB);\r\n    }\r\n}\r\n/**\r\n * Delete any records of bindings for a particular element and primary binding pair.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n */\r\nfunction _forgetElementBindings(element, fn) {\r\n    const elementB = boundEvents.get(element);\r\n    if (!elementB) {\r\n        return;\r\n    }\r\n    elementB.delete(fn);\r\n    boundEvents.delete(element);\r\n}\r\n/**\r\n * Return the bindings for a particular element and primary binding pair.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n */\r\nfunction _getElementBindings(element, fn) {\r\n    const elementB = boundEvents.get(element);\r\n    if (!elementB) {\r\n        return undefined;\r\n    }\r\n    const fnB = elementB.get(fn);\r\n    return fnB;\r\n}\r\n/**\r\n * Checks whether or not any bindings are recorded for a particular element and primary binding pair.\r\n *\r\n * @param  {HTMLElement} element\r\n *\r\n * @return {boolean}\r\n */\r\nfunction _getElementHasBindings(element) {\r\n    return boundEvents.has(element);\r\n}\r\nfunction _makeEnterFn(fn) {\r\n    return function (e) {\r\n        const isEnter = _isEnter(e);\r\n        if (isEnter) {\r\n            return fn.call(this, e);\r\n        }\r\n    };\r\n}\r\n/**\r\n * For a given KeyboardEvent, checks if it was triggered by the 'enter' key.\r\n *\r\n * @param  {KeyboardEvent} e\r\n *\r\n * @return {boolean}\r\n */\r\nfunction _isEnter(e) {\r\n    const isEnter = !!(e.key && (e.key.toLowerCase() === 'enter'));\r\n    return isEnter;\r\n}\r\n/**\r\n * For a given KeyboardEvent, if it was triggered by the 'spacebar' key, prevent the default action of scrolling the page.\r\n *\r\n * @param {KeyboardEvent} e\r\n */\r\nfunction _preventSpacebarScroll(e) {\r\n    // Prevent spacebar from scrolling the page down on keydown\r\n    const element = this;\r\n    // Buttons and inputs don't have this default action of the 'spacebar' key, so don't prevent it.\r\n    const isButton = element instanceof HTMLButtonElement;\r\n    const isInput = element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement;\r\n    const isSpacebar = _isSpacebar(e);\r\n    if (!isButton && !isInput && isSpacebar) {\r\n        e.preventDefault();\r\n    }\r\n}\r\n/**\r\n * Create a secondary binding that calls fn when triggered via the spacebar.\r\n *\r\n * @param {ActivateEventListener} fn\r\n */\r\nfunction _makeSpacebarFn(fn) {\r\n    return function (e) {\r\n        const isSpacebar = _isSpacebar(e);\r\n        if (isSpacebar) {\r\n            return fn.call(this, e);\r\n        }\r\n    };\r\n}\r\n/**\r\n * Checks if a given KeyboardEvent was triggered by the 'spacebar' key.\r\n *\r\n * @param  {KeyboardEvent} e\r\n *\r\n * @return {boolean}\r\n */\r\nfunction _isSpacebar(e) {\r\n    // IE11 uses 'spacebar' instead of ' '\r\n    const isSpacebar = !!(e.key && (e.key === ' ' || e.key.toLowerCase() === 'spacebar'));\r\n    return isSpacebar;\r\n}\r\n/**\r\n * Bind fn to all specified elements.\r\n *\r\n * @param {string | HTMLElement | NodeListOf<HTMLElement>} elements - The elements to have fn bound to them.\r\n * @param {ActivateEventListener} fn - The event listener to bind.\r\n *\r\n * @throws {DOMException} - If the elements argument is an invalid CSS selector string.\r\n */\r\nfunction activate(elements, fn) {\r\n    _activator(elements, fn, _activateSingle);\r\n}\r\n/**\r\n * Unbind fn from all specified elements.\r\n *\r\n * @param {string | HTMLElement | NodeListOf<HTMLElement>} elements - The elements to have fn unbound from them.\r\n * @param {ActivateEventListener} fn - The event listener to unbind.\r\n *\r\n * @throws {DOMException} - If the elements argument is an invalid CSS selector string.\r\n */\r\nfunction deactivate(elements, fn) {\r\n    _activator(elements, fn, _deactivateSingle);\r\n}\r\nexport { activate, deactivate, };\r\nexport default activate;\r\n//# sourceMappingURL=activate.js.map"],"names":["Mode","Map","Object","freeze","toggle","light","dark","allowTransitions"],"sourceRoot":""}