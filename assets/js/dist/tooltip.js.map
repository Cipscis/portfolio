{"version":3,"file":"tooltip.js","mappings":"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","sources":["webpack://@cipscis/portfolio/./node_modules/@cipscis/keybinding/dist/KeyBind.js","webpack://@cipscis/portfolio/./node_modules/@cipscis/keybinding/dist/KeyPress.js","webpack://@cipscis/portfolio/./node_modules/@cipscis/keybinding/dist/keybinding.js","webpack://@cipscis/portfolio/./app/assets/js/src/tooltip/tooltip.js"],"sourcesContent":["class KeyBind extends Array {\r\n    /**\r\n     * Creates a special KeyBind array based on a string representation of a\r\n     *   key, key combination, or key sequence.\r\n     *\r\n     * @constructor\r\n     *\r\n     * @param {string} bindingString - A string representing a key, key combination, or key sequence. For example, 'esc' or 'Ctrl+G Ctrl+D'.\r\n     */\r\n    constructor(bindingString) {\r\n        if (!(typeof bindingString === 'string')) {\r\n            throw new RangeError(`KeyBind: Constructor argument must be a string`);\r\n        }\r\n        super(0);\r\n        const bindings = bindingString.trim().split(/\\s+/g);\r\n        for (const binding of bindings) {\r\n            this.push(binding);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a string representation of a KeyBind.\r\n     *\r\n     * @return {string}\r\n     */\r\n    toString() {\r\n        return this.join(' ');\r\n    }\r\n    /**\r\n     * Checks whether or not a given set of KeyPresses matches the current\r\n     *   KeyBind's criteria.\r\n     *\r\n     * @param  {KeyPress[]} keyPresses - The KeyPresses to check against.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    match(keyPresses) {\r\n        if (keyPresses.length !== this.length) {\r\n            return false;\r\n        }\r\n        for (const [i, keyPress] of keyPresses.entries()) {\r\n            const keyBind = this[i];\r\n            if (!keyPress.match(keyBind)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexport { KeyBind };\r\n//# sourceMappingURL=KeyBind.js.map","const Patterns = Object.freeze({\r\n    alt: /\\balt\\+/g,\r\n    ctrl: /\\b(control|ctrl|command|cmd|meta)\\+/g,\r\n    shift: /\\bshift\\+/g,\r\n});\r\nconst Aliases = new Map([\r\n    ['space', ' '],\r\n    ['spacebar', ' '],\r\n    ['up', 'arrowup'],\r\n    ['right', 'arrowright'],\r\n    ['down', 'arrowdown'],\r\n    ['left', 'arrowleft'],\r\n    ['esc', 'escape'],\r\n]);\r\n;\r\nclass KeyPress {\r\n    key;\r\n    modifiers;\r\n    /**\r\n     * Creates a recording of a key press, including any modifier keys that were\r\n     *   pressed at the time.\r\n     *\r\n     * @constructor\r\n     *\r\n     * @param {Object} options - Can accept a KeyboardEvent.\r\n     * @param {string} options.key - The key that was pressed.\r\n     * @param {boolean?} altKey - Whether or not the Alt key was pressed.\r\n     * @param {boolean?} metaKey - Whether or not the Meta key was pressed.\r\n     * @param {boolean?} ctrlKey - Whether or not the Ctrl key was pressed.\r\n     * @param {boolean?} shiftKey - Whether or not the Shift key was pressed.\r\n     */\r\n    constructor(options) {\r\n        if (!('key' in options)) {\r\n            throw new RangeError(`KeyPress: key is a required option`);\r\n        }\r\n        this.key = options.key;\r\n        this.modifiers = {\r\n            altKey: options.altKey || false,\r\n            ctrlKey: options.metaKey || options.ctrlKey || false,\r\n            shiftKey: options.shiftKey || false,\r\n        };\r\n    }\r\n    /**\r\n     * Checks whether or not a given string representing a key or a key\r\n     *   combination matches the current recorded KeyPress.\r\n     *\r\n     * @param  {string} keyString A string representing a key or key\r\n     *   combination. For example, 'esc' or 'Ctrl+G'.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    match(keyString) {\r\n        const requiredModifiers = {\r\n            altKey: false,\r\n            ctrlKey: false,\r\n            shiftKey: false,\r\n        };\r\n        // Gather required modifiers for keyString\r\n        if (Patterns.alt.test(keyString)) {\r\n            requiredModifiers.altKey = true;\r\n            keyString = keyString.replace(Patterns.alt, '');\r\n        }\r\n        if (Patterns.ctrl.test(keyString)) {\r\n            requiredModifiers.ctrlKey = true;\r\n            keyString = keyString.replace(Patterns.ctrl, '');\r\n        }\r\n        if (Patterns.shift.test(keyString)) {\r\n            requiredModifiers.shiftKey = true;\r\n            keyString = keyString.replace(Patterns.shift, '');\r\n        }\r\n        // Check if all keyString's required modifiers were met\r\n        let modifier;\r\n        for (modifier in requiredModifiers) {\r\n            if (requiredModifiers[modifier] && !this.modifiers[modifier]) {\r\n                // The modifier was required but not recorded\r\n                return false;\r\n            }\r\n        }\r\n        // Check if they keyString's key matches the key pressed\r\n        if (keyString.toLowerCase() === this.key.toLowerCase()) {\r\n            return true;\r\n        }\r\n        // Check if the keyString is an alias for a matching key\r\n        if (Aliases.get(keyString.toLowerCase()) === this.key.toLowerCase()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexport { KeyPress };\r\n//# sourceMappingURL=KeyPress.js.map","import { KeyBind } from './KeyBind.js';\r\nimport { KeyPress } from './KeyPress.js';\r\nconst bindings = new Map();\r\nconst defaults = Object.freeze({\r\n    allowInInput: false,\r\n});\r\n/**\r\n * Creates a wrapper for a callback function, which handles recording and\r\n *   checking keypresses so it can be bound directly to the 'keydown' event and\r\n *   decide when the callback should be invoked.\r\n *\r\n * @param {string} keyString - A string representing the key, key combination,\r\n *   or key sequence the callback should to be bound to. For example, 'esc' or\r\n *   'Ctrl+G Ctrl+D'.\r\n * @param {function} fn - The function to be bound.\r\n * @param {Object} options - Options to configure behaviour of the key binding.\r\n * @param {boolean} options.allowInInput - If set to true, the key binding will remain active while keyboard focus is in an element that can receive keyboard input, such as <input type=\"text\">.\r\n *\r\n * @return {function}\r\n */\r\nconst createFnWrapper = (keyString, fn, opts) => {\r\n    const options = Object.assign({}, defaults, opts);\r\n    const keyBind = new KeyBind(keyString);\r\n    const keyLog = [];\r\n    const fnWrapper = function (e, ...otherArgs) {\r\n        // Ignore modifier keys\r\n        if (['Alt', 'Control', 'Meta', 'Shift'].includes(e.key)) {\r\n            return;\r\n        }\r\n        // Don't check key if focus is in a prohibited place\r\n        if ((!options.allowInInput) && isInput(document.activeElement)) {\r\n            return;\r\n        }\r\n        if (isProtected(document.activeElement)) {\r\n            return;\r\n        }\r\n        const keyPress = new KeyPress(e);\r\n        keyLog.push(keyPress);\r\n        if (keyLog.length > keyBind.length) {\r\n            keyLog.shift();\r\n        }\r\n        if (keyBind.match(keyLog)) {\r\n            // Clear keyLog and call function\r\n            keyLog.splice(0);\r\n            fn.apply(this, [e, ...otherArgs]);\r\n        }\r\n    };\r\n    return fnWrapper;\r\n};\r\n/**\r\n * Binds an event to a key, key combination, or key sequence.\r\n *\r\n * @param {string} keyString - A string representing the key, key combination, or key sequence to be bound to. For example, 'esc' or 'Ctrl+G Ctrl+D'.\r\n * @param {function} fn - The function to be bound. When called, behaves as though it had been bound by document.addEventListener.\r\n * @param {Object} options - Options to configure behaviour of the key binding.\r\n * @param {boolean} options.allowInInput - If set to true, the key binding will remain active while keyboard focus is in an element that can receive keyboard input, such as <input type=\"text\">.\r\n *\r\n * @return {void}\r\n */\r\nconst bind = (keyString, fn, options) => {\r\n    if (!bindings.has(keyString)) {\r\n        bindings.set(keyString, new Map());\r\n    }\r\n    const keyStringBindings = bindings.get(keyString);\r\n    if (keyStringBindings.has(fn)) {\r\n        // Do nothing - this binding already exists\r\n        return;\r\n    }\r\n    const fnWrapper = createFnWrapper(keyString, fn, options);\r\n    document.addEventListener('keydown', fnWrapper);\r\n    keyStringBindings.set(fn, fnWrapper);\r\n};\r\n/**\r\n * Unbind an event from a key, key combination, or key sequence.\r\n *\r\n * @param {string} keyString - A string representing the key, key combination, or key sequence to unbind from. For example, 'esc' or 'Ctrl+G Ctrl+D'.\r\n * @param {function} fn - The function to be unbound.\r\n *\r\n * @return {void}\r\n */\r\nconst unbind = (keyString, fn) => {\r\n    const keyStringBindings = bindings.get(keyString);\r\n    if (!keyStringBindings) {\r\n        return;\r\n    }\r\n    const fnWrapper = keyStringBindings.get(fn);\r\n    if (fnWrapper) {\r\n        document.removeEventListener('keydown', fnWrapper);\r\n        keyStringBindings.delete(fn);\r\n    }\r\n};\r\n/**\r\n * Check if a given HTMLElement is able to receive keyboard input.\r\n *\r\n * @param  {Element | null} $element - The element to check. If it is not an\r\n *   HTMLElement, the function will return false.\r\n *\r\n * @return {boolean}\r\n */\r\nconst isInput = function ($element) {\r\n    let isInput = false;\r\n    if ($element instanceof HTMLElement) {\r\n        if ($element instanceof HTMLTextAreaElement || $element instanceof HTMLSelectElement) {\r\n            isInput = true;\r\n        }\r\n        else if ($element instanceof HTMLInputElement) {\r\n            isInput = true;\r\n            const inputType = ($element.type || 'text').toLowerCase();\r\n            if (['button', 'checkbox', 'color', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'].includes(inputType)) {\r\n                isInput = false;\r\n            }\r\n        }\r\n        else if ($element.isContentEditable) {\r\n            isInput = true;\r\n        }\r\n    }\r\n    return isInput;\r\n};\r\n/**\r\n * Check if keyboard input to an HTMLElement should never be tracked.\r\n *\r\n * @param  {Element | null} $element - The element to check. If it is not an\r\n *   HTMLElement, the function will return false.\r\n *\r\n * @return {boolean}\r\n */\r\nconst isProtected = function ($element) {\r\n    let isProtected = false;\r\n    if ($element instanceof HTMLInputElement) {\r\n        const inputType = ($element.type || 'text').toLowerCase();\r\n        if (inputType === 'password') {\r\n            isProtected = true;\r\n        }\r\n    }\r\n    return isProtected;\r\n};\r\nexport { bind, unbind, };\r\n//# sourceMappingURL=keybinding.js.map","/* Tooltip 1.0 */\n\nimport * as keys from '@cipscis/keybinding';\n\nconst tooltip = (function () {\n\tconst selectors = {\n\t\ttooltip: '.js-tooltip',\n\t\tbody: '.js-tooltip__body',\n\t};\n\n\tconst classes = {\n\t\thidden: 'tooltip--hidden',\n\t};\n\n\tlet initialised = false;\n\n\tconst module = {\n\t\tinit: function () {\n\t\t\tif (initialised === false) {\n\t\t\t\tmodule._initEvents();\n\t\t\t\tmodule._initKeybinding();\n\t\t\t}\n\n\t\t\tinitialised = true;\n\t\t},\n\n\t\t_initEvents: function () {\n\t\t\tlet $tooltips = document.querySelectorAll(selectors.tooltip);\n\n\t\t\t$tooltips.forEach(($tooltip) => {\n\t\t\t\t$tooltip.addEventListener('mouseleave', module._removeHiddenClassEvent($tooltip));\n\t\t\t\t$tooltip.addEventListener('focusout', module._processTooltipFocusOut);\n\t\t\t});\n\t\t},\n\n\t\t_initKeybinding: function () {\n\t\t\tkeys.bind('escape', module._hideOpenTooltips);\n\t\t},\n\n\t\t_hideOpenTooltips: function () {\n\t\t\tlet $tooltips = module._getOpenTooltips();\n\n\t\t\t$tooltips.forEach(($tooltip) => {\n\t\t\t\t$tooltip.classList.add(classes.hidden);\n\t\t\t});\n\t\t},\n\n\t\t_removeHiddenClassEvent: function ($tooltip) {\n\t\t\treturn (e) => {\n\t\t\t\tif (document.activeElement !== $tooltip) {\n\t\t\t\t\tmodule._removeHiddenClass($tooltip);\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\t_removeHiddenClass: function ($tooltip) {\n\t\t\t$tooltip.classList.remove(classes.hidden);\n\t\t},\n\n\t\t_processTooltipFocusOut: function (e) {\n\t\t\t// Make asynchronous so new activeElement can be detected\n\t\t\twindow.setTimeout(() => {\n\t\t\t\tlet $oldFocus = e.target;\n\t\t\t\tlet $newFocus = document.activeElement;\n\n\t\t\t\tlet $oldTooltip = module._getClosestTooltip($oldFocus);\n\t\t\t\tlet $newTooltip = module._getClosestTooltip($newFocus);\n\n\t\t\t\tif ($oldTooltip !== $newTooltip) {\n\t\t\t\t\tmodule._removeHiddenClass($oldTooltip);\n\t\t\t\t}\n\t\t\t}, 0);\n\t\t},\n\n\t\t_getOpenTooltips: function () {\n\t\t\tlet $openBodies = module._getOpenTooltipBodies();\n\n\t\t\tlet $tooltips = [];\n\t\t\t$openBodies.forEach(($el) => {\n\t\t\t\tlet $tooltip = module._getClosestTooltip($el);\n\n\t\t\t\tif ($tooltip) {\n\t\t\t\t\t$tooltips.push($tooltip);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('Could not find tooltip of open body:', $el);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn $tooltips;\n\t\t},\n\n\t\t_getOpenTooltipBodies: function () {\n\t\t\tlet $bodies = document.querySelectorAll(selectors.body);\n\t\t\tlet $openBodies = Array.from($bodies).filter(($el) => {\n\t\t\t\treturn $el.offsetParent !== null;\n\t\t\t});\n\n\t\t\treturn $openBodies;\n\t\t},\n\n\t\t_getClosestTooltip: function ($el) {\n\t\t\tlet $tooltip = $el;\n\t\t\twhile ($tooltip && $tooltip.matches(selectors.tooltip) === false) {\n\t\t\t\t$tooltip = $tooltip.parentElement;\n\t\t\t}\n\n\t\t\treturn $tooltip;\n\t\t},\n\t};\n\n\treturn {\n\t\tinit: module.init,\n\t};\n})();\n\n// Self-initialise\ntooltip.init();\n\nexport default tooltip;\n"],"names":["KeyBind","Array","constructor","bindingString","RangeError","super","bindings","trim","split","binding","this","push","toString","join","match","keyPresses","length","i","keyPress","entries","keyBind","Patterns","Object","freeze","alt","ctrl","shift","Aliases","Map","KeyPress","key","modifiers","options","altKey","ctrlKey","metaKey","shiftKey","keyString","requiredModifiers","modifier","test","replace","toLowerCase","get","defaults","allowInInput","createFnWrapper","fn","opts","assign","keyLog","e","otherArgs","includes","isInput","document","activeElement","isProtected","splice","apply","$element","HTMLElement","HTMLTextAreaElement","HTMLSelectElement","HTMLInputElement","inputType","type","isContentEditable","selectors","classes","initialised","module","init","_initEvents","_initKeybinding","querySelectorAll","forEach","$tooltip","addEventListener","_removeHiddenClassEvent","_processTooltipFocusOut","has","set","keyStringBindings","fnWrapper","_hideOpenTooltips","_getOpenTooltips","classList","add","_removeHiddenClass","remove","window","setTimeout","$oldFocus","target","$newFocus","$oldTooltip","_getClosestTooltip","$openBodies","_getOpenTooltipBodies","$tooltips","$el","console","error","$bodies","from","filter","offsetParent","matches","parentElement"],"sourceRoot":""}