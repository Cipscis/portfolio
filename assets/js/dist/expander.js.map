{"version":3,"file":"expander.js","mappings":"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","sources":["webpack://@cipscis/portfolio/./node_modules/@cipscis/activate/dist/activate.js","webpack://@cipscis/portfolio/./app/assets/js/src/expander/expander.js"],"sourcesContent":["const boundEvents = new Map();\r\n/**\r\n * Handles the conversion of the elements parameter so the activator function only ever has to deal with single HTMLElements.\r\n *\r\n * @param {string | HTMLElement | NodeListOf<HTMLElement>} elements - A CSS selector string, HTMLElement, or NodeList of HTMLElements to be converted so the activator function is called once for each resulting HTMLElement.\r\n * @param {ActivateEventListener} fn - The event listener to bind to each HTMLElement.\r\n * @param {(element: HTMLElement, fn: ActivateEventListener) => void} activator - The function to link each HTMLElement to fn.\r\n *\r\n * @throws {DOMException} - If the elements argument is an invalid CSS selector string.\r\n */\r\nfunction _activator(elements, fn, activator) {\r\n    // Share the same initial logic between activate and deactivate,\r\n    // but run a different function over each element\r\n    if (typeof elements === 'string') {\r\n        try {\r\n            elements = document.querySelectorAll(elements);\r\n        }\r\n        catch (e) {\r\n            const method = activator === _deactivateSingle ? 'deactivate' : 'activate';\r\n            throw new DOMException(`${method} failed because it was passed an invalid selector string: '${elements}'`);\r\n        }\r\n    }\r\n    if (elements instanceof HTMLElement) {\r\n        activator(elements, fn);\r\n    }\r\n    else {\r\n        elements.forEach((element) => activator(element, fn));\r\n    }\r\n}\r\n/**\r\n * Binds fn to a single element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n *\r\n * @throws {TypeError} - element must be an HTMLElement.\r\n */\r\nfunction _activateSingle(element, fn) {\r\n    if (!(element instanceof HTMLElement)) {\r\n        throw new TypeError(`activate failed because a valid HTMLElement was not passed`);\r\n    }\r\n    if (_getElementBindings(element, fn)) {\r\n        // Like addEventListener, don't try to rebind new copies of the same events\r\n        return;\r\n    }\r\n    // All nodes should bind the click event\r\n    element.addEventListener('click', fn);\r\n    // Buttons will already treat keyboard events like clicks,\r\n    // so only bind them to other element types\r\n    if (!(element instanceof HTMLButtonElement)) {\r\n        if (_getElementHasBindings(element) === false) {\r\n            // addEventListener would prevent this event being\r\n            // bound multiple times, but be explicit that it is\r\n            // only bound if the element has no other events bound\r\n            element.addEventListener('keydown', _preventSpacebarScroll);\r\n        }\r\n        const spacebarFn = _makeSpacebarFn(fn);\r\n        element.addEventListener('keyup', spacebarFn);\r\n        const bindings = {\r\n            spacebarFn\r\n        };\r\n        // Links already treat \"enter\" keydown like a click\r\n        if (!(element instanceof HTMLAnchorElement)) {\r\n            // Note that holding down \"enter\" will behave differently\r\n            // for links in that it will only fire once, whereas for\r\n            // non-links, including buttons, it will fire multiple times\r\n            const enterFn = _makeEnterFn(fn);\r\n            element.addEventListener('keydown', enterFn);\r\n            bindings.enterFn = enterFn;\r\n        }\r\n        _rememberElementBindings(element, fn, bindings);\r\n    }\r\n}\r\n/**\r\n * Unbinds fn from a single element.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n *\r\n * @throws {TypeError} - element must be an HTMLElement.\r\n */\r\nfunction _deactivateSingle(element, fn) {\r\n    if (!(element instanceof HTMLElement)) {\r\n        throw new TypeError(`deactivate failed because a valid HTMLElement was not passed`);\r\n    }\r\n    // All elements have had a click event bound\r\n    element.removeEventListener('click', fn);\r\n    const bindings = _getElementBindings(element, fn);\r\n    if (!bindings) {\r\n        // No other events to unbind\r\n        return;\r\n    }\r\n    // Buttons will already treat keyboard events like clicks,\r\n    // so they didn't have keyboard events bound to them\r\n    if (!(element instanceof HTMLButtonElement)) {\r\n        if (bindings.spacebarFn) {\r\n            element.removeEventListener('keyup', bindings.spacebarFn);\r\n        }\r\n        // Links already treat \"enter\" keydown like a click,\r\n        // so that event wasn't bound to them\r\n        if (!(element instanceof HTMLAnchorElement)) {\r\n            if (bindings.enterFn) {\r\n                element.removeEventListener('keydown', bindings.enterFn);\r\n            }\r\n        }\r\n        _forgetElementBindings(element, fn);\r\n        if (_getElementHasBindings(element) === false) {\r\n            // Only unbind this event if the element has no other bindings\r\n            element.removeEventListener('keydown', _preventSpacebarScroll);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Record a new set of bindings for a particular element, associated with a new primary binding.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn - The primary binding.\r\n * @param {ActivateBinding} bindings - The secondary bindings.\r\n */\r\nfunction _rememberElementBindings(element, fn, bindings) {\r\n    let elementB = boundEvents.get(element);\r\n    if (!elementB) {\r\n        elementB = new Map([[fn, bindings]]);\r\n        boundEvents.set(element, elementB);\r\n    }\r\n    let fnB = elementB.get(fn);\r\n    if (fnB) {\r\n        Object.assign(fnB, bindings);\r\n    }\r\n    else {\r\n        fnB = Object.assign({}, bindings);\r\n        elementB.set(fn, fnB);\r\n    }\r\n}\r\n/**\r\n * Delete any records of bindings for a particular element and primary binding pair.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n */\r\nfunction _forgetElementBindings(element, fn) {\r\n    const elementB = boundEvents.get(element);\r\n    if (!elementB) {\r\n        return;\r\n    }\r\n    elementB.delete(fn);\r\n    boundEvents.delete(element);\r\n}\r\n/**\r\n * Return the bindings for a particular element and primary binding pair.\r\n *\r\n * @param {HTMLElement} element\r\n * @param {ActivateEventListener} fn\r\n */\r\nfunction _getElementBindings(element, fn) {\r\n    const elementB = boundEvents.get(element);\r\n    if (!elementB) {\r\n        return undefined;\r\n    }\r\n    const fnB = elementB.get(fn);\r\n    return fnB;\r\n}\r\n/**\r\n * Checks whether or not any bindings are recorded for a particular element and primary binding pair.\r\n *\r\n * @param  {HTMLElement} element\r\n *\r\n * @return {boolean}\r\n */\r\nfunction _getElementHasBindings(element) {\r\n    return boundEvents.has(element);\r\n}\r\nfunction _makeEnterFn(fn) {\r\n    return function (e) {\r\n        const isEnter = _isEnter(e);\r\n        if (isEnter) {\r\n            return fn.call(this, e);\r\n        }\r\n    };\r\n}\r\n/**\r\n * For a given KeyboardEvent, checks if it was triggered by the 'enter' key.\r\n *\r\n * @param  {KeyboardEvent} e\r\n *\r\n * @return {boolean}\r\n */\r\nfunction _isEnter(e) {\r\n    const isEnter = !!(e.key && (e.key.toLowerCase() === 'enter'));\r\n    return isEnter;\r\n}\r\n/**\r\n * For a given KeyboardEvent, if it was triggered by the 'spacebar' key, prevent the default action of scrolling the page.\r\n *\r\n * @param {KeyboardEvent} e\r\n */\r\nfunction _preventSpacebarScroll(e) {\r\n    // Prevent spacebar from scrolling the page down on keydown\r\n    const element = this;\r\n    // Buttons and inputs don't have this default action of the 'spacebar' key, so don't prevent it.\r\n    const isButton = element instanceof HTMLButtonElement;\r\n    const isInput = element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement;\r\n    const isSpacebar = _isSpacebar(e);\r\n    if (!isButton && !isInput && isSpacebar) {\r\n        e.preventDefault();\r\n    }\r\n}\r\n/**\r\n * Create a secondary binding that calls fn when triggered via the spacebar.\r\n *\r\n * @param {ActivateEventListener} fn\r\n */\r\nfunction _makeSpacebarFn(fn) {\r\n    return function (e) {\r\n        const isSpacebar = _isSpacebar(e);\r\n        if (isSpacebar) {\r\n            return fn.call(this, e);\r\n        }\r\n    };\r\n}\r\n/**\r\n * Checks if a given KeyboardEvent was triggered by the 'spacebar' key.\r\n *\r\n * @param  {KeyboardEvent} e\r\n *\r\n * @return {boolean}\r\n */\r\nfunction _isSpacebar(e) {\r\n    // IE11 uses 'spacebar' instead of ' '\r\n    const isSpacebar = !!(e.key && (e.key === ' ' || e.key.toLowerCase() === 'spacebar'));\r\n    return isSpacebar;\r\n}\r\n/**\r\n * Bind fn to all specified elements.\r\n *\r\n * @param {string | HTMLElement | NodeListOf<HTMLElement>} elements - The elements to have fn bound to them.\r\n * @param {ActivateEventListener} fn - The event listener to bind.\r\n *\r\n * @throws {DOMException} - If the elements argument is an invalid CSS selector string.\r\n */\r\nfunction activate(elements, fn) {\r\n    _activator(elements, fn, _activateSingle);\r\n}\r\n/**\r\n * Unbind fn from all specified elements.\r\n *\r\n * @param {string | HTMLElement | NodeListOf<HTMLElement>} elements - The elements to have fn unbound from them.\r\n * @param {ActivateEventListener} fn - The event listener to unbind.\r\n *\r\n * @throws {DOMException} - If the elements argument is an invalid CSS selector string.\r\n */\r\nfunction deactivate(elements, fn) {\r\n    _activator(elements, fn, _deactivateSingle);\r\n}\r\nexport { activate, deactivate, };\r\nexport default activate;\r\n//# sourceMappingURL=activate.js.map","/* Expander 1.2 */\n\nimport { activate } from '@cipscis/activate';\n\nconst expander = (function (activate) {\n\tconst selectors = {\n\t\tsection: '.js-expander',\n\t\ttrigger: '.js-expander__trigger',\n\t};\n\n\tconst States = {\n\t\tOPENED: 'Opened',\n\t\tCLOSED: 'Closed',\n\t};\n\n\tconst module = {\n\t\tinit: function () {\n\t\t\tmodule._initEvents();\n\n\t\t\t// If no JS, expanders will be open\n\t\t\tmodule._closeByDefault();\n\n\t\t\twindow.addEventListener('load', module._openByHash);\n\t\t},\n\n\t\t_initEvents: function () {\n\t\t\tlet $triggers = document.querySelectorAll(selectors.trigger);\n\n\t\t\tactivate($triggers, module._toggleEvent);\n\n\t\t\twindow.addEventListener('hashchange', module._openByHash);\n\t\t},\n\n\n\t\t_toggleEvent: function (e) {\n\t\t\te.preventDefault();\n\n\t\t\tlet $trigger = e.target.closest(selectors.trigger);\n\n\t\t\tlet $section = module._getTriggerSection($trigger);\n\t\t\tmodule._toggleSection($section);\n\t\t},\n\n\t\t_getTriggerSection: function ($trigger) {\n\t\t\t// 1. If a trigger has an aria-controls attribute, its section is\n\t\t\t// the section with the matching id attribute.\n\n\t\t\t// 2. If there is no matching section, or if the trigger has no\n\t\t\t// aria-controls attribute, its section is the most recent\n\t\t\t// ancestor that is an expandable section\n\n\t\t\t// 3. Otherwise, the trigger has no matching section\n\n\t\t\tlet $section;\n\n\t\t\tlet controls = $trigger.getAttribute('aria-controls');\n\n\t\t\tif (controls) {\n\t\t\t\t$section = document.getElementById(controls);\n\t\t\t\tif (!$section) {\n\t\t\t\t\tconsole.warn(`Could not find expander section with ID '${controls}'`);\n\t\t\t\t}\n\t\t\t} else if (!$section) {\n\t\t\t\t$section = $trigger.closest(selectors.section);\n\t\t\t}\n\n\t\t\treturn $section;\n\t\t},\n\n\t\t_getSectionTriggers: function ($section) {\n\t\t\t// Inverse of _getTriggerSection\n\n\t\t\tlet $allTriggers = Array.from(document.querySelectorAll(selectors.trigger));\n\t\t\tlet $matchingTriggers = $allTriggers.filter(($trigger) => module._getTriggerSection($trigger) === $section);\n\n\t\t\treturn $matchingTriggers;\n\t\t},\n\n\n\t\t_toggleSection: function ($section, desiredState) {\n\t\t\tif (typeof desiredState === 'undefined') {\n\t\t\t\tlet state = module._getSectionState($section);\n\n\t\t\t\tif (state === States.CLOSED) {\n\t\t\t\t\tdesiredState = States.OPENED;\n\t\t\t\t} else if (state === States.OPENED) {\n\t\t\t\t\tdesiredState = States.CLOSED;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmodule._setSectionState($section, desiredState);\n\t\t},\n\n\n\t\t_getSectionState: function ($section) {\n\t\t\tlet ariaExpanded = $section.getAttribute('aria-expanded');\n\n\t\t\tlet state = States.UNDEFINED;\n\t\t\tif (ariaExpanded === 'true') {\n\t\t\t\tstate = States.OPENED;\n\t\t\t} else if (ariaExpanded === 'false') {\n\t\t\t\tstate = States.CLOSED;\n\t\t\t}\n\n\t\t\treturn state;\n\t\t},\n\n\t\t_setSectionState: function ($section, state) {\n\t\t\tlet $triggers = module._getSectionTriggers($section);\n\n\t\t\tif (state === States.OPENED) {\n\n\t\t\t\t$section.setAttribute('aria-expanded', 'true');\n\t\t\t\t$triggers.forEach(($trigger) => $trigger.setAttribute('aria-expanded', 'true'));\n\n\t\t\t} else if (state === States.CLOSED) {\n\n\t\t\t\t$section.setAttribute('aria-expanded', 'false');\n\t\t\t\t$triggers.forEach(($trigger) => $trigger.setAttribute('aria-expanded', 'false'));\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error(`Unrecognised state '${state}'`);\n\n\t\t\t}\n\t\t},\n\n\n\t\t_closeByDefault: function () {\n\t\t\tlet $sections = document.querySelectorAll(selectors.section);\n\n\t\t\t$sections.forEach(($section) => {\n\t\t\t\tmodule._setSectionState($section, States.CLOSED);\n\t\t\t});\n\t\t},\n\n\n\t\t_openByHash: function () {\n\t\t\t// If URL contains a hash to an element within a collapsed section,\n\t\t\t// expand that section then scroll to the element\n\n\t\t\t// TODO: Allow clicking an anchor link to the current hash to\n\t\t\t// force relevant expanders to open again, if they've been closed\n\n\t\t\tlet hash = document.location.hash;\n\n\t\t\tif (hash.length) {\n\t\t\t\tlet $hash = document.querySelector(hash);\n\n\t\t\t\tif ($hash) {\n\t\t\t\t\t// Expand the containing section\n\t\t\t\t\tlet $expander = $hash.closest(selectors.section);\n\n\t\t\t\t\tif ($expander) {\n\t\t\t\t\t\tmodule._setSectionState($expander, States.OPENED);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If there are higher levels of expanders, expand them too\n\t\t\t\t\twhile ($expander) {\n\t\t\t\t\t\t$expander = $expander.parentElement;\n\n\t\t\t\t\t\tif ($expander) {\n\t\t\t\t\t\t\t$expander = $expander.closest(selectors.section);\n\n\t\t\t\t\t\t\tif ($expander) {\n\t\t\t\t\t\t\t\tmodule._setSectionState($expander, States.OPENED);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Scroll to the given element\n\t\t\t\t\t// Only works if asynchronous\n\t\t\t\t\twindow.setTimeout(() => $hash.scrollIntoView(), 0);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t};\n\n\treturn {\n\t\tinit: module.init,\n\t};\n})(activate);\n\n// Self-initialise\nexpander.init();\n\nexport default expander;\n"],"names":["boundEvents","Map","_activator","elements","fn","activator","document","querySelectorAll","e","DOMException","_deactivateSingle","HTMLElement","forEach","element","_activateSingle","TypeError","_getElementBindings","addEventListener","HTMLButtonElement","_getElementHasBindings","_preventSpacebarScroll","spacebarFn","_isSpacebar","call","this","_makeSpacebarFn","bindings","HTMLAnchorElement","enterFn","isEnter","key","toLowerCase","_isEnter","_makeEnterFn","elementB","get","set","fnB","Object","assign","_rememberElementBindings","removeEventListener","delete","_forgetElementBindings","has","isButton","isInput","HTMLInputElement","HTMLTextAreaElement","isSpacebar","preventDefault","expander","activate","selectors","States","OPENED","CLOSED","module","init","_initEvents","_closeByDefault","window","_openByHash","$triggers","_toggleEvent","$trigger","target","closest","$section","_getTriggerSection","_toggleSection","controls","getAttribute","getElementById","console","warn","_getSectionTriggers","Array","from","filter","desiredState","state","_getSectionState","_setSectionState","ariaExpanded","UNDEFINED","setAttribute","error","hash","location","length","$hash","querySelector","$expander","parentElement","setTimeout","scrollIntoView"],"sourceRoot":""}